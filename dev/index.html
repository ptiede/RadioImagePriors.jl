<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · VLBIImagePriors.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://ptiede.github.io/VLBIImagePriors.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>VLBIImagePriors.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="VLBIImagePriors"><a class="docs-heading-anchor" href="#VLBIImagePriors">VLBIImagePriors</a><a id="VLBIImagePriors-1"></a><a class="docs-heading-anchor-permalink" href="#VLBIImagePriors" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/ptiede/VLBIImagePriors.jl">VLBIImagePriors</a>.</p><ul><li><a href="#VLBIImagePriors.AdditiveLR"><code>VLBIImagePriors.AdditiveLR</code></a></li><li><a href="#VLBIImagePriors.AngleTransform"><code>VLBIImagePriors.AngleTransform</code></a></li><li><a href="#VLBIImagePriors.CenterImage-Tuple{AxisKeys.KeyedArray{T, N, &lt;:Any, G} where {T, N, G&lt;:ComradeBase.AbstractDims}}"><code>VLBIImagePriors.CenterImage</code></a></li><li><a href="#VLBIImagePriors.CenteredLR"><code>VLBIImagePriors.CenteredLR</code></a></li><li><a href="#VLBIImagePriors.CenteredRegularizer"><code>VLBIImagePriors.CenteredRegularizer</code></a></li><li><a href="#VLBIImagePriors.DiagonalVonMises"><code>VLBIImagePriors.DiagonalVonMises</code></a></li><li><a href="#VLBIImagePriors.GaussMarkovRandomField-Tuple{ComradeBase.AbstractModel, ComradeBase.AbstractDims, Vararg{Any}}"><code>VLBIImagePriors.GaussMarkovRandomField</code></a></li><li><a href="#VLBIImagePriors.GaussMarkovRandomField-Tuple{AbstractMatrix, Number, Number, MarkovRandomFieldCache}"><code>VLBIImagePriors.GaussMarkovRandomField</code></a></li><li><a href="#VLBIImagePriors.GaussMarkovRandomField"><code>VLBIImagePriors.GaussMarkovRandomField</code></a></li><li><a href="#VLBIImagePriors.GaussMarkovRandomField-Tuple{AbstractMatrix, Any, Any}"><code>VLBIImagePriors.GaussMarkovRandomField</code></a></li><li><a href="#VLBIImagePriors.ImageDirichlet"><code>VLBIImagePriors.ImageDirichlet</code></a></li><li><a href="#VLBIImagePriors.ImageSimplex"><code>VLBIImagePriors.ImageSimplex</code></a></li><li><a href="#VLBIImagePriors.ImageSphericalUniform"><code>VLBIImagePriors.ImageSphericalUniform</code></a></li><li><a href="#VLBIImagePriors.ImageUniform"><code>VLBIImagePriors.ImageUniform</code></a></li><li><a href="#VLBIImagePriors.MarkovRandomFieldCache"><code>VLBIImagePriors.MarkovRandomFieldCache</code></a></li><li><a href="#VLBIImagePriors.MarkovRandomFieldCache-Tuple{Type{&lt;:Number}, Tuple{Int64, Int64}}"><code>VLBIImagePriors.MarkovRandomFieldCache</code></a></li><li><a href="#VLBIImagePriors.MarkovRandomFieldCache-Tuple{ComradeBase.AbstractDims}"><code>VLBIImagePriors.MarkovRandomFieldCache</code></a></li><li><a href="#VLBIImagePriors.NamedDist-Union{Tuple{NamedTuple{N}}, Tuple{N}} where N"><code>VLBIImagePriors.NamedDist</code></a></li><li><a href="#VLBIImagePriors.SphericalUnitVector"><code>VLBIImagePriors.SphericalUnitVector</code></a></li><li><a href="#VLBIImagePriors.TDistMarkovRandomField-Tuple{ComradeBase.AbstractModel, ComradeBase.AbstractDims, Vararg{Any}}"><code>VLBIImagePriors.TDistMarkovRandomField</code></a></li><li><a href="#VLBIImagePriors.TDistMarkovRandomField-Tuple{AbstractMatrix, Any, Any, Any, MarkovRandomFieldCache}"><code>VLBIImagePriors.TDistMarkovRandomField</code></a></li><li><a href="#VLBIImagePriors.TDistMarkovRandomField"><code>VLBIImagePriors.TDistMarkovRandomField</code></a></li><li><a href="#VLBIImagePriors.TDistMarkovRandomField-Tuple{AbstractMatrix, Any, Any, Any}"><code>VLBIImagePriors.TDistMarkovRandomField</code></a></li><li><a href="#VLBIImagePriors.WrappedUniform"><code>VLBIImagePriors.WrappedUniform</code></a></li><li><a href="#VLBIImagePriors.alr!-Tuple{Any, Any}"><code>VLBIImagePriors.alr!</code></a></li><li><a href="#VLBIImagePriors.alrinv!-Tuple{Any, Any}"><code>VLBIImagePriors.alrinv!</code></a></li><li><a href="#VLBIImagePriors.clr!-Tuple{Any, Any}"><code>VLBIImagePriors.clr!</code></a></li><li><a href="#VLBIImagePriors.clrinv!-Tuple{Any, Any}"><code>VLBIImagePriors.clrinv!</code></a></li><li><a href="#VLBIImagePriors.to_real-Tuple{VLBIImagePriors.LogRatioTransform, Any}"><code>VLBIImagePriors.to_real</code></a></li><li><a href="#VLBIImagePriors.to_simplex-Tuple{VLBIImagePriors.LogRatioTransform, Any}"><code>VLBIImagePriors.to_simplex</code></a></li><li><a href="#VLBIImagePriors.to_simplex!-Tuple{AdditiveLR, Any, Any}"><code>VLBIImagePriors.to_simplex!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.AdditiveLR" href="#VLBIImagePriors.AdditiveLR"><code>VLBIImagePriors.AdditiveLR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AdditiveLR &lt;: LogRatioTransform</code></pre><p>Defines the additive log-ratio transform. The <code>clr</code> transformation moves from the simplex Sⁿ → <span>$R^{n-1}$</span> and is given by</p><pre><code class="nohighlight hljs">alr(x) = [log(x₁/xₙ) ... log(xₙ/xₙ)],</code></pre><p>where <code>g(x) = (∏xᵢ)ⁿ⁻¹</code> is the geometric mean. The inverse transformation is given by</p><pre><code class="nohighlight hljs">alr⁻¹(x) = exp.(x)./(1 + sum(x[1:n-1])).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/logratio_transform.jl#L25-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.AngleTransform" href="#VLBIImagePriors.AngleTransform"><code>VLBIImagePriors.AngleTransform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AngleTransform</code></pre><p>A transformation that moves two vector <code>x</code> and <code>y</code> to an angle <code>θ</code>.  Note that is <code>x</code> and <code>y</code> are normally distributed then the resulting distribution in <code>θ</code> is uniform on the circle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/angular_transforms.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.CenterImage-Tuple{AxisKeys.KeyedArray{T, N, &lt;:Any, G} where {T, N, G&lt;:ComradeBase.AbstractDims}}" href="#VLBIImagePriors.CenterImage-Tuple{AxisKeys.KeyedArray{T, N, &lt;:Any, G} where {T, N, G&lt;:ComradeBase.AbstractDims}}"><code>VLBIImagePriors.CenterImage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CenterImage(X, Y)
CenterImage(img::IntensityMap)
CenterImage(grid::ComradeBase.AbstractDims)</code></pre><p>Constructs a projections operator that will take an arbritrary image and return a transformed version whose centroid is at the origin.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>, <code>Y</code>: the iterators for the image pixel locations</li><li><code>img</code>: A <code>IntensityMap</code> whose grid is the same as the image you want to center</li><li><code>grid</code>: The grid that the image is defined on.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using ComradeBase: centroid, imagepixels
julia&gt; grid = imagepixels(μas2rad(100.0), μas2rad(100.0), 256, 256)
julia&gt; K = CenterImage(grid)
julia&gt; img = IntensityMap(rand(256, 256), grid)
julia&gt; centroid(img)
(1.34534e-10, 5.23423e-11)
julia&gt; cimg = K(img)
julia&gt; centroid(cimg)
(1.231e-14, -2.43e-14)</code></pre><p><strong>Note</strong></p><p>This center image works using a linear projection operator. This means that is does not necessarily preserve the image total flux and the positive definiteness of the image. In practise we find that the deviation from the original flux, and the amount of negative flux is small.</p><p><strong>Explanation</strong></p><p>The centroid is constructed by</p><pre><code class="nohighlight hljs">X ⋅ I = 0
Y ⋅ I = 0</code></pre><p>where <code>I</code> is the flattened image of length <code>N</code>, and <code>X</code> and <code>Y</code> are the image pixel locations. This can be simplified into the matrix equation</p><pre><code class="nohighlight hljs">XY ⋅ I = 0</code></pre><p>where <code>XY</code> is the <code>2×N</code> matrix whose first for is given by <code>X</code> and second is <code>Y</code>. The space of centered images is then given by the null space of <code>XY</code>. Given this we can form a matrix <code>C</code> which is the kernel matrix of the nullspace whose columns are the orthogonal basis vectors of the null space of <code>XY</code>. Using this we can construct a centered image projection opertor by</p><pre><code class="nohighlight hljs">K = CC&#39;.</code></pre><p>Our centered image is then given by <code>I₀ = KI</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/centered.jl#L77-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.CenteredLR" href="#VLBIImagePriors.CenteredLR"><code>VLBIImagePriors.CenteredLR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CenteredLR &lt;: LogRatioTransform</code></pre><p>Defines the centered log-ratio transform. The <code>clr</code> transformation moves from the simplex Sⁿ → Rⁿ and is given by</p><pre><code class="nohighlight hljs">clr(x) = [log(x₁/g(x)) ... log(xₙ/g(x))]</code></pre><p>where <code>g(x) = (∏xᵢ)ⁿ⁻¹</code> is the geometric mean. The inverse transformation is given by the softmax function and is only defined on a subset of the domain otherwise it is not injective</p><pre><code class="nohighlight hljs">clr⁻¹(x) = exp.(x)./sum(exp, x).</code></pre><p><strong>Notes</strong></p><p>As mentioned above this transformation is bijective on the entire codomain of the function. However, unlike the additive log-ratio transform it does not treat any pixel as being special.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/logratio_transform.jl#L5-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.CenteredRegularizer" href="#VLBIImagePriors.CenteredRegularizer"><code>VLBIImagePriors.CenteredRegularizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CenteredRegularizer(x, y, σ, p)</code></pre><p>Regularizes a general image prior <code>p</code> such that the center of light is close the the origin of the imag. After regularization the log density of the prior is modified to</p><p class="math-container">\[    \log p(I) \to \log p(I) - \frac{(x_C^2 + y_C^2)^2}{2\sigma\^2} N_x N_y\]</p><p>where <code>N_x</code> and <code>N_y</code> are the number of pixels in the <code>x</code> and <code>y</code> direction of the image, and <span>$x_C, y_C$</span> are the center of light of the image <code>I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/centered.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.DiagonalVonMises" href="#VLBIImagePriors.DiagonalVonMises"><code>VLBIImagePriors.DiagonalVonMises</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DiagonalVonMises(μ::Real, κ::Real)
DiagonalVonMises(μ::AbstractVector{&lt;:Real}, κ::AbstractVector{&lt;:Real})</code></pre><p>Constructs a Von Mises distribution, with mean <code>μ</code> and concentraion parameter <code>κ</code>. If <code>μ</code> and <code>κ</code> are vectors then this constructs a independent multivariate Von Mises distribution.</p><p><strong>Notes</strong></p><p>This is a custom implementation since the version in <code>Distributions.jl</code> has certain properties that do not play well (having an support only between [-π+μ, π+μ]) with usual VLBI problems. Additionally this distribution has a special overloaded <code>product_distribution</code> method so that concatenating multiple <code>DiagonalVonMises</code> together preserves the type. This is helpful for <code>Zygote</code> autodiff.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/angular_dists.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.GaussMarkovRandomField" href="#VLBIImagePriors.GaussMarkovRandomField"><code>VLBIImagePriors.GaussMarkovRandomField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GaussMarkovRandomField{T, M&lt;:AbstractArray{T, 2}, P, C, TDi} &lt;: VLBIImagePriors.MarkovRandomField</code></pre><p>A image prior based off of the first-order Gaussian Markov random field with mean image <code>m</code>. This prior is similar to the combination of <em>total squared variation</em> TSV and L₂ norm, and is given by</p><pre><code class="nohighlight hljs">(λ²π²Σ)⁻¹ TSV(I-M) + (π²Σ)L₂(I-M) + lognorm(λ, Σ)</code></pre><p>where λ and Σ are the inverse correlation length and variance of the random field and <code>lognorm(λ,Σ)</code> is the log-normalization of the random field. This normalization is needed to jointly infer <code>I</code> and the hyperparameters λ, Σ.</p><p><strong>Fields</strong></p><ul><li><p><code>m</code></p><p>The mean image of the Gaussian Markov random field</p></li></ul><ul><li><p><code>λ</code></p><p>The inverse correlation length of the random field.</p></li></ul><ul><li><p><code>Σ</code></p><p>The variance of the random field</p></li></ul><ul><li><p><code>cache</code></p><p>The Markov Random Field cache used to define the specific Markov random field class used.</p></li></ul><ul><li><p><code>dims</code></p><p>The dimensions of the image.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; mimg = zeros(6, 6) # The mean image
julia&gt; λ, Σ = 2.0, 1.0
julia&gt; d = GaussMarkovRandomField(mimg, λ, Σ)
julia&gt; cache = MarkovRandomFieldCache(mimg) # now instead construct the cache
julia&gt; d2 = GaussMarkovRandomField(mimg, λ, Σ, cache)
julia&gt; invcov(d) ≈ invcov(d2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/markovrf/gmrf.jl#L7-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.GaussMarkovRandomField-Tuple{AbstractMatrix, Any, Any}" href="#VLBIImagePriors.GaussMarkovRandomField-Tuple{AbstractMatrix, Any, Any}"><code>VLBIImagePriors.GaussMarkovRandomField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GaussMarkovRandomField(mean::AbstractMatrix, λ, Σ)</code></pre><p>Constructs a first order Gaussian Markov random field with mean image <code>mean</code> and inverse correlation <code>λ</code> and diagonal covariance <code>Σ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/markovrf/gmrf.jl#L66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.GaussMarkovRandomField-Tuple{AbstractMatrix, Number, Number, MarkovRandomFieldCache}" href="#VLBIImagePriors.GaussMarkovRandomField-Tuple{AbstractMatrix, Number, Number, MarkovRandomFieldCache}"><code>VLBIImagePriors.GaussMarkovRandomField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GaussMarkovRandomField(λ, Σ, cache::MarkovRandomFieldCache)
GaussMarkovRandomField(mean::AbstractMatrix, λ, Σ, cache::MarkovRandomFieldCache)</code></pre><p>Constructs a first order Gaussian Markov random field with mean image <code>mean</code> and inverse correlation <code>λ</code> and diagonal covariance <code>Σ</code> and the precomputed MarkovRandomFieldCache <code>cache</code>. If <code>mean</code> is not included then it is assume the mean is identically zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/markovrf/gmrf.jl#L113-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.GaussMarkovRandomField-Tuple{ComradeBase.AbstractModel, ComradeBase.AbstractDims, Vararg{Any}}" href="#VLBIImagePriors.GaussMarkovRandomField-Tuple{ComradeBase.AbstractModel, ComradeBase.AbstractDims, Vararg{Any}}"><code>VLBIImagePriors.GaussMarkovRandomField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GaussMarkovRandomField(mean::ComradeBase.AbstractModel, grid::ComradeBase.AbstractDims, λ, Σ [,cache]; transform=identity)</code></pre><p>Create a <code>GaussMarkovRandomField</code> object using a ComradeBase model.</p><p><strong>Arguments</strong></p><ul><li><code>mean</code>: A ComradeBase model that will define the mean image</li><li><code>grid</code>: The grid on which the image of the model will be created. This calls <code>ComradeBase.intensitymap</code>.</li><li><code>λ</code>: The inverse correlation length of the GMRF</li><li><code>Σ</code>: The variance of the GMRF</li><li><code>cache</code>: Optionally specify the precomputed MarkovRandomFieldCache</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>transform = identity</code>: A transform to apply to the image when creating the mean image. See the examples.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; m1 = GaussMarkovRandomField(Gaussian(), imagepixels(10.0, 10.0, 128, 128), 5.0, 1.0; transform=alr)
julia&gt; cache = MarkovRandomFieldCache(Gaussian(), imagepixels(10.0, 10.0, 128, 128), 5.0, 1.0; transform=alr)
julia&gt; m2 = GaussMarkovRandomField(Gaussian(), imagepixels(10.0, 10.0, 128, 128), 5.0, 1.0, cache; transform=alr)
julia&gt; m1 == m2
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/markovrf/gmrf.jl#L83-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.ImageDirichlet" href="#VLBIImagePriors.ImageDirichlet"><code>VLBIImagePriors.ImageDirichlet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImageDirichlet(α::AbstractMatrix)
ImageDirichlet(α::Real, ny, nx)</code></pre><p>A Dirichlet distribution defined on a matrix. Samples from this produce matrices whose elements sum to unity. This is a useful image prior when you want to separately constrain the flux. The  α parameter defines the usual Dirichlet concentration amount.</p><p><strong>Notes</strong></p><p>Much of this code was taken from <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl</a> and it&#39;s Dirichlet distribution. However, some changes were made to make it faster. Additionally, we use define a custom <code>rrule</code> to speed up derivatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/dirichlet.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.ImageSimplex" href="#VLBIImagePriors.ImageSimplex"><code>VLBIImagePriors.ImageSimplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImageSimplex(ny,nx)</code></pre><p>This defines a transformation from ℝⁿ⁻¹ to the <code>n</code> probability simplex defined on an matrix with dimension <code>ny×nx</code>. This is a more natural transformation for rasterized images, which are most naturally represented as a matrix.</p><p><strong>Notes</strong></p><p>Much of this code was inspired by <a href="https://github.com/tpapp/TransformVariables.jl">TransformVariables</a>. However, we have specified custom <code>rrules</code> using Enzyme as a backend. This allowed the simplex transform to be used with Zygote and we achieved an order of magnitude speedup when computing the pullback of the simplex transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/imagesimplex.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.ImageSphericalUniform" href="#VLBIImagePriors.ImageSphericalUniform"><code>VLBIImagePriors.ImageSphericalUniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImageSphericalUniform(nx, ny)</code></pre><p>Construct a distribution where each image pixel is a 3-sphere uniform variable. This is useful for polarization where the stokes parameters are parameterized on the 3-sphere.</p><p>Currently we use a struct of vectors memory layout. That is the image is described by three matrices <code>(X,Y,Z)</code> grouped together as a tuple, where each matrix is one direction on the sphere, and we require <code>norm((X,Y,Z)) == 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/uniform.jl#L53-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.ImageUniform" href="#VLBIImagePriors.ImageUniform"><code>VLBIImagePriors.ImageUniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImageUniform(a::Real, b::Real, nx, ny)</code></pre><p>A uniform distribution in image pixels where <code>a/b</code> are the lower/upper bound for the interval. This then concatenates ny×nx uniform distributions together.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/uniform.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.MarkovRandomFieldCache" href="#VLBIImagePriors.MarkovRandomFieldCache"><code>VLBIImagePriors.MarkovRandomFieldCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MarkovRandomFieldCache{A, TD, M}</code></pre><p>A cache for a Markov random field.</p><p><strong>Fields</strong></p><ul><li><p><code>Λ</code></p><p>Intrinsic Gaussian Random Field pseudo-precison matrix. This is similar to the TSV regularizer</p></li></ul><ul><li><p><code>D</code></p><p>Gaussian Random Field diagonal precision matrix. This is similar to the L2-regularizer</p></li></ul><ul><li><p><code>λQ</code></p><p>The eigenvalues of the Λ matrix which is needed to compute the log-normalization constant of the GMRF.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; mean = zeros(2,2) # define a zero mean
julia&gt; cache = GRMFCache(mean)
julia&gt; prior_map(x) = GaussMarkovRandomField(mean, x[1], x[2], cache)
julia&gt; d = HierarchicalPrior(prior_map, product_distribution([Uniform(-5.0,5.0), Uniform(0.0, 10.0)]))
julia&gt; x0 = rand(d)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/markovrf/cache.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.MarkovRandomFieldCache-Tuple{ComradeBase.AbstractDims}" href="#VLBIImagePriors.MarkovRandomFieldCache-Tuple{ComradeBase.AbstractDims}"><code>VLBIImagePriors.MarkovRandomFieldCache</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MarkovRandomFieldCache(grid::AbstractDims)</code></pre><p>Create a GMRF cache out of a <code>Comrade</code> model as the mean image.</p><p><strong>Arguments</strong></p><ul><li><code>m</code>: Comrade model used for the mean image.</li><li><code>grid</code>: The grid of points you want to create the model image on.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>transform = identity</code>: A transform to apply to the image when creating the mean image. See the examples</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = MarkovRandomFieldCache(imagepixels(10.0, 10.0, 64, 64))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/markovrf/cache.jl#L60-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.MarkovRandomFieldCache-Tuple{Type{&lt;:Number}, Tuple{Int64, Int64}}" href="#VLBIImagePriors.MarkovRandomFieldCache-Tuple{Type{&lt;:Number}, Tuple{Int64, Int64}}"><code>VLBIImagePriors.MarkovRandomFieldCache</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MarkovRandomFieldCache(mean::AbstractMatrix)</code></pre><p>Contructs the <a href="#VLBIImagePriors.MarkovRandomFieldCache"><code>MarkovRandomFieldCache</code></a> from the mean image <code>mean</code>. This is useful for hierarchical priors where you change the hyperparameters of the <a href="#VLBIImagePriors.GaussMarkovRandomField"><code>GaussMarkovRandomField</code></a>, λ and <code>Σ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/markovrf/cache.jl#L38-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.NamedDist-Union{Tuple{NamedTuple{N}}, Tuple{N}} where N" href="#VLBIImagePriors.NamedDist-Union{Tuple{NamedTuple{N}}, Tuple{N}} where N"><code>VLBIImagePriors.NamedDist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NamedDist(d::NamedTuple{N})
NamedDist(;dists...)</code></pre><p>A Distribution with names <code>N</code>. This is useful to construct a set of random variables with a set of names attached to them.</p><pre><code class="language-julia-repl hljs">julia&gt; d = NamedDist((a=Normal(), b = Uniform(), c = MvNormal(randn(2), rand(2))))
julia&gt; x = rand(d)
(a = 0.13789342, b = 0.2347895, c = [2.023984392, -3.09023840923])
julia&gt; logpdf(d, x)</code></pre><p>Note that NamedDist values passed to NamedDist can also be abstract collections of distributions as well</p><pre><code class="language-julia-repl hljs">julia&gt; d = NamedDist(a = Normal(),
                     b = MvNormal(ones(2)),
                     c = (Uniform(), InverseGamma())
                     d = (a = Normal(), Beta)
                    )</code></pre><p>How this is done internally is considered an implementation detail and is not part of the public interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/namedist.jl#L45-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.SphericalUnitVector" href="#VLBIImagePriors.SphericalUnitVector"><code>VLBIImagePriors.SphericalUnitVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SphericalUnitVector{N}()</code></pre><p>A transformation from a set of <code>N+1</code> vectors to the <code>N</code> sphere. The set of <code>N+1</code> vectors are inherently assumed to be <code>N+1</code> a distributed according to a unit multivariate Normal distribution.</p><p><strong>Notes</strong></p><p>For more information about this transformation see the Stan <a href="https://mc-stan.org/docs/reference-manual/unit-vector.html">manual</a>. In the future this may be depricated when <a href="https://github.com/tpapp/TransformVariables.jl/pull/67"></a> is merged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/angular_transforms.jl#L64-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.TDistMarkovRandomField" href="#VLBIImagePriors.TDistMarkovRandomField"><code>VLBIImagePriors.TDistMarkovRandomField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TDistMarkovRandomField{T, M&lt;:AbstractArray{T, 2}, P, C, TDi} &lt;: VLBIImagePriors.MarkovRandomField</code></pre><p>A image prior based off of the first-order Multivariate T distribution Markov random field.</p><p><strong>Fields</strong></p><ul><li><p><code>m</code></p><p>The mean image of the TDist Markov random field</p></li></ul><ul><li><p><code>λ</code></p><p>The inverse correlation length of the random field.</p></li></ul><ul><li><p><code>Σ</code></p><p>The variance of the random field</p></li></ul><ul><li><p><code>ν</code></p><p>The student T &quot;degrees of freedom parameter which ≥ 1 for a proper prior</p></li></ul><ul><li><p><code>cache</code></p><p>The Markov Random Field cache used to define the specific Markov random field class used.</p></li></ul><ul><li><p><code>dims</code></p><p>The dimensions of the image.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; mimg = zeros(6, 6) # The mean image
julia&gt; λ, Σ = 2.0, 1.0
julia&gt; d = TDistMarkovRandomField(mimg, λ, Σ)
julia&gt; cache = MarkovRandomFieldCache(mimg) # now instead construct the cache
julia&gt; d2 = TDistMarkovRandomField(mimg, λ, Σ, cache)
julia&gt; invcov(d) ≈ invcov(d2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/markovrf/studentTrf.jl#L7-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.TDistMarkovRandomField-Tuple{AbstractMatrix, Any, Any, Any, MarkovRandomFieldCache}" href="#VLBIImagePriors.TDistMarkovRandomField-Tuple{AbstractMatrix, Any, Any, Any, MarkovRandomFieldCache}"><code>VLBIImagePriors.TDistMarkovRandomField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TDistMarkovRandomField(mean::AbstractMatrix, λ, Σ, cache::MarkovRandomFieldCache)</code></pre><p>Constructs a first order TDist Markov random field with mean image <code>mean</code> and inverse correlation <code>λ</code> and diagonal covariance <code>Σ</code> and the precomputed MarkovRandomFieldCache <code>cache</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/markovrf/studentTrf.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.TDistMarkovRandomField-Tuple{AbstractMatrix, Any, Any, Any}" href="#VLBIImagePriors.TDistMarkovRandomField-Tuple{AbstractMatrix, Any, Any, Any}"><code>VLBIImagePriors.TDistMarkovRandomField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TDistMarkovRandomField(mean::AbstractMatrix, λ, Σ)</code></pre><p>Constructs a first order TDist Markov random field with mean image <code>mean</code> and inverse correlation <code>λ</code> and diagonal covariance <code>Σ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/markovrf/studentTrf.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.TDistMarkovRandomField-Tuple{ComradeBase.AbstractModel, ComradeBase.AbstractDims, Vararg{Any}}" href="#VLBIImagePriors.TDistMarkovRandomField-Tuple{ComradeBase.AbstractModel, ComradeBase.AbstractDims, Vararg{Any}}"><code>VLBIImagePriors.TDistMarkovRandomField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TDistMarkovRandomField(mean::ComradeBase.AbstractModel, grid::ComradeBase.AbstractDims, λ, Σ [,cache]; transform=identity)</code></pre><p>Create a <code>TDistMarkovRandomField</code> object using a ComradeBase model.</p><p><strong>Arguments</strong></p><ul><li><code>mean</code>: A ComradeBase model that will define the mean image</li><li><code>grid</code>: The grid on which the image of the model will be created. This calls <code>ComradeBase.intensitymap</code>.</li><li><code>λ</code>: The inverse correlation length of the GMRF</li><li><code>Σ</code>: The variance of the GMRF</li><li><code>cache</code>: Optionally specify the precomputed MarkovRandomFieldCache</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>transform = identity</code>: A transform to apply to the image when creating the mean image. See the examples.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; m1 = TDistMarkovRandomField(TDist(), imagepixels(10.0, 10.0, 128, 128), 5.0, 1.0; transform=alr)
julia&gt; cache = MarkovRandomFieldCache(TDist(), imagepixels(10.0, 10.0, 128, 128), 5.0, 1.0; transform=alr)
julia&gt; m2 = TDistMarkovRandomField(TDist(), imagepixels(10.0, 10.0, 128, 128), 5.0, 1.0, cache; transform=alr)
julia&gt; m1 == m2
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/markovrf/studentTrf.jl#L73-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.WrappedUniform" href="#VLBIImagePriors.WrappedUniform"><code>VLBIImagePriors.WrappedUniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WrappedUniform(period)</code></pre><p>Constructs a potentially multivariate uniform distribution that is wrapped a given <code>period</code>. That is</p><pre><code class="language-julia hljs">d = WrappedUniform(period)
logpdf(d, x) ≈ logpdf(d, x+period)</code></pre><p>for any <code>x</code>.</p><p>If <code>period</code> is a vector this creates a multivariate independent wrapped uniform distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/angular_dists.jl#L110-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.alr!-Tuple{Any, Any}" href="#VLBIImagePriors.alr!-Tuple{Any, Any}"><code>VLBIImagePriors.alr!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alr!(x, y)</code></pre><p>Compute the inverse alr transform. That is <code>x</code> lives in ℜⁿ and <code>y</code>, lives in Δⁿ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/logratio_transform.jl#L211-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.alrinv!-Tuple{Any, Any}" href="#VLBIImagePriors.alrinv!-Tuple{Any, Any}"><code>VLBIImagePriors.alrinv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alrinv!(x, y)</code></pre><p>Computes the additive logit transform inplace. This converts from ℜⁿ → Δⁿ where Δⁿ is the n-simplex</p><p><strong>Notes</strong></p><p>This function is mainly to transform the GaussMarkovRandomField to live on the simplex. In order to preserve the nice properties of the GRMF namely the log det we only use <code>y[begin:end-1]</code> elements and the last one is not included in the transform. This shouldn&#39;t be a problem since the additional parameter is just a dummy in that case and the Gaussian prior should ensure it is easy to sample from.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/logratio_transform.jl#L143-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.clr!-Tuple{Any, Any}" href="#VLBIImagePriors.clr!-Tuple{Any, Any}"><code>VLBIImagePriors.clr!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clr!(x, y)</code></pre><p>Compute the inverse alr transform. That is <code>x</code> lives in ℜⁿ and <code>y</code>, lives in Δⁿ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/logratio_transform.jl#L199-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.clrinv!-Tuple{Any, Any}" href="#VLBIImagePriors.clrinv!-Tuple{Any, Any}"><code>VLBIImagePriors.clrinv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clrinv!(x, y)</code></pre><p>Computes the additive logit transform inplace. This converts from ℜⁿ → Δⁿ where Δⁿ is the n-simplex</p><p><strong>Notes</strong></p><p>This function is mainly to transform the GaussMarkovRandomField to live on the simplex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/logratio_transform.jl#L126-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.to_real-Tuple{VLBIImagePriors.LogRatioTransform, Any}" href="#VLBIImagePriors.to_real-Tuple{VLBIImagePriors.LogRatioTransform, Any}"><code>VLBIImagePriors.to_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_real(t::LogRatioTransform, y)</code></pre><p>Transform the value <code>u</code> that lives on the simplex to a value in the real vector space. See <code>subtypes(LogRatioTransform)</code> for a list of possible transformations.</p><p>The inverse of this transform is given by <a href="#VLBIImagePriors.to_simplex-Tuple{VLBIImagePriors.LogRatioTransform, Any}"><code>to_simplex(t, x)</code></a>.</p><p><strong>Example</strong></p><p>```julia julia&gt; y = randn(100) julia&gt; y .= y./sum(y) julia&gt; to<em>real(CenteredLR(), y) julia&gt; to</em>real(AdditiveLR(), y)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/logratio_transform.jl#L93-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.to_simplex!-Tuple{AdditiveLR, Any, Any}" href="#VLBIImagePriors.to_simplex!-Tuple{AdditiveLR, Any, Any}"><code>VLBIImagePriors.to_simplex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_simplex!(t::LogRatioTransform, y, x)</code></pre><p>Transform the vector <code>x</code> assumed to be a real valued array to the simplex using the log-ratio transform <code>t</code> and stores the value in <code>y</code>.</p><p>The inverse of this transform is given by <a href="@ref"><code>to_real!(t, x, y)</code></a> where <code>y</code> is a vector that sums to unity, i.e. it lives on the simplex.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; x = randn(100)
julia&gt; to_simplex(CenteredLR(), x)
julia&gt; to_simplex(AdditiveLR(), x)

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/logratio_transform.jl#L65-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.to_simplex-Tuple{VLBIImagePriors.LogRatioTransform, Any}" href="#VLBIImagePriors.to_simplex-Tuple{VLBIImagePriors.LogRatioTransform, Any}"><code>VLBIImagePriors.to_simplex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_simplex(t::LogRatioTransform, x)</code></pre><p>Transform the vector <code>x</code> assumed to be a real valued array to the simplex using the log-ratio transform <code>t</code>. See <code>subtypes(LogRatioTransform)</code> for a list of possible transformations.</p><p>The inverse of this transform is given by <a href="#VLBIImagePriors.to_real-Tuple{VLBIImagePriors.LogRatioTransform, Any}"><code>to_real(t, y)</code></a> where <code>y</code> is a vector that sums to unity, i.e. it lives on the simplex.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; x = randn(100)
julia&gt; to_simplex(CenteredLR(), x)
julia&gt; to_simplex(AdditiveLR(), x)

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/57be720ba35d88bbfa363672818e44bbf7c11850/src/logratio_transform.jl#L40-L58">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Tuesday 19 September 2023 19:18">Tuesday 19 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
