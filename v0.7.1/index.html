<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · VLBIImagePriors.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://ptiede.github.io/VLBIImagePriors.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>VLBIImagePriors.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="VLBIImagePriors"><a class="docs-heading-anchor" href="#VLBIImagePriors">VLBIImagePriors</a><a id="VLBIImagePriors-1"></a><a class="docs-heading-anchor-permalink" href="#VLBIImagePriors" title="Permalink"></a></h1><p>This package implements a number of priors that are helpful when imaging VLBI data. These priors include commonly used Bayesian Stokes I imaging priors such as </p><ul><li>Log Uniform prior from <a href="https://iopscience.iop.org/article/10.3847/1538-4357/ab9c1f">Broderick et al. 2020</a></li><li>Dirichlet prior from <a href="https://iopscience.iop.org/article/10.3847/1538-3881/abe3f8/pdf">Pesce 2021</a></li><li>Gaussian Markov Random Field (see <a href="mrf/#Markov-Random-Field-Priors">Markov Random Field Priors</a>)</li></ul><p>For polarized imaging we also include a number of useful priors that parameterize the unit n-sphere which are required to parameterize the Poincaré sphere <a href="polarization/#Polarization-Priors">Polarization Priors</a>.</p><p>In addition we include a <a href="#VLBIImagePriors.NamedDist-Union{Tuple{NamedTuple{N}}, Tuple{N}} where N"><code>NamedDist</code></a> which is a distribution composed of <code>NamedTuples</code>. This distribution also attempts to be rather smart and does certain conversions automatically, such at converting an array and/or tuple of distributions to a <code>Distributions.jl</code> object. </p><p>Documentation for <a href="https://github.com/ptiede/VLBIImagePriors.jl">VLBIImagePriors</a>.</p><ul><li><a href="#VLBIImagePriors.AdditiveLR"><code>VLBIImagePriors.AdditiveLR</code></a></li><li><a href="#VLBIImagePriors.AngleTransform"><code>VLBIImagePriors.AngleTransform</code></a></li><li><a href="#VLBIImagePriors.CenterImage-Tuple{ComradeBase.IntensityMap}"><code>VLBIImagePriors.CenterImage</code></a></li><li><a href="#VLBIImagePriors.CenteredLR"><code>VLBIImagePriors.CenteredLR</code></a></li><li><a href="#VLBIImagePriors.CenteredRegularizer"><code>VLBIImagePriors.CenteredRegularizer</code></a></li><li><a href="#VLBIImagePriors.ConditionalMarkov-Tuple{Type{&lt;:VLBIImagePriors.MarkovRandomField}, Vararg{Any}}"><code>VLBIImagePriors.ConditionalMarkov</code></a></li><li><a href="#VLBIImagePriors.DiagonalVonMises"><code>VLBIImagePriors.DiagonalVonMises</code></a></li><li><a href="#VLBIImagePriors.EMRF"><code>VLBIImagePriors.EMRF</code></a></li><li><a href="#VLBIImagePriors.ExpMarkovRandomField-Tuple{Number, AbstractMatrix}"><code>VLBIImagePriors.ExpMarkovRandomField</code></a></li><li><a href="#VLBIImagePriors.ExpMarkovRandomField"><code>VLBIImagePriors.ExpMarkovRandomField</code></a></li><li><a href="#VLBIImagePriors.ExpMarkovRandomField-Tuple{Number, MarkovRandomFieldGraph}"><code>VLBIImagePriors.ExpMarkovRandomField</code></a></li><li><a href="#VLBIImagePriors.ExpMarkovRandomField-Tuple{Number, Tuple{Int64, Int64}}"><code>VLBIImagePriors.ExpMarkovRandomField</code></a></li><li><a href="#VLBIImagePriors.GMRF"><code>VLBIImagePriors.GMRF</code></a></li><li><a href="#VLBIImagePriors.GaussMarkovRandomField-Tuple{Number, Tuple{Int64, Int64}}"><code>VLBIImagePriors.GaussMarkovRandomField</code></a></li><li><a href="#VLBIImagePriors.GaussMarkovRandomField-Tuple{Number, AbstractMatrix}"><code>VLBIImagePriors.GaussMarkovRandomField</code></a></li><li><a href="#VLBIImagePriors.GaussMarkovRandomField-Tuple{Number, MarkovRandomFieldGraph}"><code>VLBIImagePriors.GaussMarkovRandomField</code></a></li><li><a href="#VLBIImagePriors.ImageDirichlet"><code>VLBIImagePriors.ImageDirichlet</code></a></li><li><a href="#VLBIImagePriors.ImageSimplex"><code>VLBIImagePriors.ImageSimplex</code></a></li><li><a href="#VLBIImagePriors.ImageSphericalUniform"><code>VLBIImagePriors.ImageSphericalUniform</code></a></li><li><a href="#VLBIImagePriors.ImageUniform"><code>VLBIImagePriors.ImageUniform</code></a></li><li><a href="#VLBIImagePriors.MarkovRandomField"><code>VLBIImagePriors.MarkovRandomField</code></a></li><li><a href="#VLBIImagePriors.MarkovRandomFieldGraph-Tuple{ComradeBase.AbstractGrid}"><code>VLBIImagePriors.MarkovRandomFieldGraph</code></a></li><li><a href="#VLBIImagePriors.NamedDist-Union{Tuple{NamedTuple{N}}, Tuple{N}} where N"><code>VLBIImagePriors.NamedDist</code></a></li><li><a href="#VLBIImagePriors.SphericalUnitVector"><code>VLBIImagePriors.SphericalUnitVector</code></a></li><li><a href="#VLBIImagePriors.TDistMarkovRandomField-Tuple{Number, Number, MarkovRandomFieldGraph}"><code>VLBIImagePriors.TDistMarkovRandomField</code></a></li><li><a href="#VLBIImagePriors.TDistMarkovRandomField"><code>VLBIImagePriors.TDistMarkovRandomField</code></a></li><li><a href="#VLBIImagePriors.TDistMarkovRandomField-Tuple{Number, Number, AbstractMatrix}"><code>VLBIImagePriors.TDistMarkovRandomField</code></a></li><li><a href="#VLBIImagePriors.TDistMarkovRandomField-Tuple{Number, Number, Tuple{Int64, Int64}}"><code>VLBIImagePriors.TDistMarkovRandomField</code></a></li><li><a href="#VLBIImagePriors.TMRF"><code>VLBIImagePriors.TMRF</code></a></li><li><a href="#VLBIImagePriors.WrappedUniform"><code>VLBIImagePriors.WrappedUniform</code></a></li><li><a href="#VLBIImagePriors.alr!-Tuple{Any, Any}"><code>VLBIImagePriors.alr!</code></a></li><li><a href="#VLBIImagePriors.alrinv!-Tuple{Any, Any}"><code>VLBIImagePriors.alrinv!</code></a></li><li><a href="#VLBIImagePriors.clr!-Tuple{Any, Any}"><code>VLBIImagePriors.clr!</code></a></li><li><a href="#VLBIImagePriors.clrinv!-Tuple{Any, Any}"><code>VLBIImagePriors.clrinv!</code></a></li><li><a href="#VLBIImagePriors.corrparam-Tuple{VLBIImagePriors.MarkovRandomField}"><code>VLBIImagePriors.corrparam</code></a></li><li><a href="#VLBIImagePriors.graph-Tuple{VLBIImagePriors.MarkovRandomField}"><code>VLBIImagePriors.graph</code></a></li><li><a href="#VLBIImagePriors.matern-Tuple{Type{&lt;:Number}, Tuple{Int64, Int64}}"><code>VLBIImagePriors.matern</code></a></li><li><a href="#VLBIImagePriors.matern-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>VLBIImagePriors.matern</code></a></li><li><a href="#VLBIImagePriors.scalematrix-Tuple{VLBIImagePriors.MarkovRandomField}"><code>VLBIImagePriors.scalematrix</code></a></li><li><a href="#VLBIImagePriors.to_real-Tuple{VLBIImagePriors.LogRatioTransform, Any}"><code>VLBIImagePriors.to_real</code></a></li><li><a href="#VLBIImagePriors.to_simplex-Tuple{VLBIImagePriors.LogRatioTransform, Any}"><code>VLBIImagePriors.to_simplex</code></a></li><li><a href="#VLBIImagePriors.to_simplex!-Tuple{AdditiveLR, Any, Any}"><code>VLBIImagePriors.to_simplex!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.AdditiveLR" href="#VLBIImagePriors.AdditiveLR"><code>VLBIImagePriors.AdditiveLR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AdditiveLR &lt;: LogRatioTransform</code></pre><p>Defines the additive log-ratio transform. The <code>clr</code> transformation moves from the simplex Sⁿ → <span>$R^{n-1}$</span> and is given by</p><pre><code class="nohighlight hljs">alr(x) = [log(x₁/xₙ) ... log(xₙ/xₙ)],</code></pre><p>where <code>g(x) = (∏xᵢ)ⁿ⁻¹</code> is the geometric mean. The inverse transformation is given by</p><pre><code class="nohighlight hljs">alr⁻¹(x) = exp.(x)./(1 + sum(x[1:n-1])).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/logratio_transform.jl#L25-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.AngleTransform" href="#VLBIImagePriors.AngleTransform"><code>VLBIImagePriors.AngleTransform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AngleTransform</code></pre><p>A transformation that moves two vector <code>x</code> and <code>y</code> to an angle <code>θ</code>.  Note that is <code>x</code> and <code>y</code> are normally distributed then the resulting distribution in <code>θ</code> is uniform on the circle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/angular_transforms.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.CenterImage-Tuple{ComradeBase.IntensityMap}" href="#VLBIImagePriors.CenterImage-Tuple{ComradeBase.IntensityMap}"><code>VLBIImagePriors.CenterImage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CenterImage(X, Y)
CenterImage(img::IntensityMap)
CenterImage(grid::RectiGrid)</code></pre><p>Constructs a projections operator that will take an arbritrary image and return a transformed version whose centroid is at the origin.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>, <code>Y</code>: the iterators for the image pixel locations</li><li><code>img</code>: A <code>IntensityMap</code> whose grid is the same as the image you want to center</li><li><code>grid</code>: The grid that the image is defined on.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using ComradeBase: centroid, imagepixels
julia&gt; grid = imagepixels(μas2rad(100.0), μas2rad(100.0), 256, 256)
julia&gt; K = CenterImage(grid)
julia&gt; img = IntensityMap(rand(256, 256), grid)
julia&gt; centroid(img)
(1.34534e-10, 5.23423e-11)
julia&gt; cimg = K(img)
julia&gt; centroid(cimg)
(1.231e-14, -2.43e-14)</code></pre><p><strong>Note</strong></p><p>This center image works using a linear projection operator. This means that is does not necessarily preserve the image total flux and the positive definiteness of the image. In practise we find that the deviation from the original flux, and the amount of negative flux is small.</p><p><strong>Explanation</strong></p><p>The centroid is constructed by</p><pre><code class="nohighlight hljs">X ⋅ I = 0
Y ⋅ I = 0</code></pre><p>where <code>I</code> is the flattened image of length <code>N</code>, and <code>X</code> and <code>Y</code> are the image pixel locations. This can be simplified into the matrix equation</p><pre><code class="nohighlight hljs">XY ⋅ I = 0</code></pre><p>where <code>XY</code> is the <code>2×N</code> matrix whose first for is given by <code>X</code> and second is <code>Y</code>. The space of centered images is then given by the null space of <code>XY</code>. Given this we can form a matrix <code>C</code> which is the kernel matrix of the nullspace whose columns are the orthogonal basis vectors of the null space of <code>XY</code>. Using this we can construct a centered image projection opertor by</p><pre><code class="nohighlight hljs">K = CC&#39;.</code></pre><p>Our centered image is then given by <code>I₀ = KI</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/centered.jl#L77-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.CenteredLR" href="#VLBIImagePriors.CenteredLR"><code>VLBIImagePriors.CenteredLR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CenteredLR &lt;: LogRatioTransform</code></pre><p>Defines the centered log-ratio transform. The <code>clr</code> transformation moves from the simplex Sⁿ → Rⁿ and is given by</p><pre><code class="nohighlight hljs">clr(x) = [log(x₁/g(x)) ... log(xₙ/g(x))]</code></pre><p>where <code>g(x) = (∏xᵢ)ⁿ⁻¹</code> is the geometric mean. The inverse transformation is given by the softmax function and is only defined on a subset of the domain otherwise it is not injective</p><pre><code class="nohighlight hljs">clr⁻¹(x) = exp.(x)./sum(exp, x).</code></pre><p><strong>Notes</strong></p><p>As mentioned above this transformation is bijective on the entire codomain of the function. However, unlike the additive log-ratio transform it does not treat any pixel as being special.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/logratio_transform.jl#L5-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.CenteredRegularizer" href="#VLBIImagePriors.CenteredRegularizer"><code>VLBIImagePriors.CenteredRegularizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CenteredRegularizer(x, y, σ, p)</code></pre><p>Regularizes a general image prior <code>p</code> such that the center of light is close the the origin of the imag. After regularization the log density of the prior is modified to</p><p class="math-container">\[    \log p(I) \to \log p(I) - \frac{(x_C^2 + y_C^2)^2}{2\sigma\^2} N_x N_y\]</p><p>where <code>N_x</code> and <code>N_y</code> are the number of pixels in the <code>x</code> and <code>y</code> direction of the image, and <span>$x_C, y_C$</span> are the center of light of the image <code>I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/centered.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.ConditionalMarkov-Tuple{Type{&lt;:VLBIImagePriors.MarkovRandomField}, Vararg{Any}}" href="#VLBIImagePriors.ConditionalMarkov-Tuple{Type{&lt;:VLBIImagePriors.MarkovRandomField}, Vararg{Any}}"><code>VLBIImagePriors.ConditionalMarkov</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ConditionalMarkov(D, args...)</code></pre><p>Creates a Conditional Markov measure, that behaves as a Julia functional. The functional returns a probability measure defined by the arguments passed to the functional.</p><p><strong>Arguments</strong></p><ul><li><code>D</code>: The &lt;: <code>MarkovRandomField</code> that defines the underlying measure</li><li><code>args</code>: Additional arguments used to construct the Markov random field cache.         See <a href="#VLBIImagePriors.MarkovRandomFieldGraph-Tuple{ComradeBase.AbstractGrid}"><code>MarkovRandomFieldGraph</code></a> for more information.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; grid = imagepixels(10.0, 10.0, 64, 64)
julia&gt; ℓ = ConditionalMarkov(GaussMarkovRandomField, grid)
julia&gt; d = ℓ(16) # This is now a distribution
julia&gt; rand(d)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/markovrf/conditional.jl#L7-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.DiagonalVonMises" href="#VLBIImagePriors.DiagonalVonMises"><code>VLBIImagePriors.DiagonalVonMises</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DiagonalVonMises(μ::Real, κ::Real)
DiagonalVonMises(μ::AbstractVector{&lt;:Real}, κ::AbstractVector{&lt;:Real})</code></pre><p>Constructs a Von Mises distribution, with mean <code>μ</code> and concentraion parameter <code>κ</code>. If <code>μ</code> and <code>κ</code> are vectors then this constructs a independent multivariate Von Mises distribution.</p><p><strong>Notes</strong></p><p>This is a custom implementation since the version in <code>Distributions.jl</code> has certain properties that do not play well (having an support only between [-π+μ, π+μ]) with usual VLBI problems. Additionally this distribution has a special overloaded <code>product_distribution</code> method so that concatenating multiple <code>DiagonalVonMises</code> together preserves the type. This is helpful for <code>Zygote</code> autodiff.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/angular_dists.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.EMRF" href="#VLBIImagePriors.EMRF"><code>VLBIImagePriors.EMRF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Alias for `ExpMarkovRandomField`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/markovrf/exponential.jl#L34-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.ExpMarkovRandomField" href="#VLBIImagePriors.ExpMarkovRandomField"><code>VLBIImagePriors.ExpMarkovRandomField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExpMarkovRandomField{T&lt;:Number, C} &lt;: VLBIImagePriors.MarkovRandomField</code></pre><p>A image prior based off of the zero mean unit variance Exponential Markov random field. The order of the Markov random field is specified</p><p><strong>Fields</strong></p><ul><li><code>ρ</code>: The correlation length of the random field.</li></ul><ul><li><code>graph</code>: The Markov Random Field graph cache used to define the specific Markov random field class used.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; ρ = 10.0
julia&gt; d = ExpMarkovRandomField(ρ, (32, 32))
julia&gt; cache = MarkovRandomFieldGraph(Float64, (32, 32)) # now instead construct the cache
julia&gt; d2 = ExpMarkovRandomField(ρ, cache)
julia&gt; scalematrix(d) ≈ scalematrix(d2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/markovrf/exponential.jl#L3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.ExpMarkovRandomField-Tuple{Number, AbstractMatrix}" href="#VLBIImagePriors.ExpMarkovRandomField-Tuple{Number, AbstractMatrix}"><code>VLBIImagePriors.ExpMarkovRandomField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ExpMarkovRandomField(ρ, img::AbstractArray; order::Integer=1)</code></pre><p>Constructs a <code>order</code>ᵗʰ order  Exponential Markov random field with dimensions <code>size(img)</code>, correlation <code>ρ</code> and unit covariance.</p><p>The <code>order</code> parameter controls the smoothness of the field with higher orders being smoother. We recommend sticking with either <code>order=1,2</code>. For more information about the impact of the order see <a href="#VLBIImagePriors.MarkovRandomFieldGraph-Tuple{ComradeBase.AbstractGrid}"><code>MarkovRandomFieldGraph</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/markovrf/exponential.jl#L46-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.ExpMarkovRandomField-Tuple{Number, MarkovRandomFieldGraph}" href="#VLBIImagePriors.ExpMarkovRandomField-Tuple{Number, MarkovRandomFieldGraph}"><code>VLBIImagePriors.ExpMarkovRandomField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ExpMarkovRandomField(ρ, cache::MarkovRandomFieldGraph)</code></pre><p>Constructs a first order zero-mean and unit variance Exponential Markov random field using the precomputed cache <code>cache</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/markovrf/exponential.jl#L77-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.ExpMarkovRandomField-Tuple{Number, Tuple{Int64, Int64}}" href="#VLBIImagePriors.ExpMarkovRandomField-Tuple{Number, Tuple{Int64, Int64}}"><code>VLBIImagePriors.ExpMarkovRandomField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ExpMarkovRandomField(ρ, dims; order=1)</code></pre><p>Constructs a first order zero-mean unit variance Exponential Markov random field with dimensions <code>dims</code>, correlation <code>ρ</code>.</p><p>The <code>order</code> parameter controls the smoothness of the field with higher orders being smoother. We recommend sticking with either <code>order=1,2</code>. For more information about the impact of the order see <a href="#VLBIImagePriors.MarkovRandomFieldGraph-Tuple{ComradeBase.AbstractGrid}"><code>MarkovRandomFieldGraph</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/markovrf/exponential.jl#L61-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.GMRF" href="#VLBIImagePriors.GMRF"><code>VLBIImagePriors.GMRF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Alias for `GaussMarkovRandomField`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/markovrf/gmrf.jl#L47-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.GaussMarkovRandomField-Tuple{Number, AbstractMatrix}" href="#VLBIImagePriors.GaussMarkovRandomField-Tuple{Number, AbstractMatrix}"><code>VLBIImagePriors.GaussMarkovRandomField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GaussMarkovRandomField(ρ, img::AbstractArray; order::Integer=1)</code></pre><p>Constructs a <code>order</code>ᵗʰ order  Gaussian Markov random field with dimensions <code>size(img)</code>, correlation <code>ρ</code> and unit covariance.</p><p>The <code>order</code> parameter controls the smoothness of the field with higher orders being smoother. We recommend sticking with either <code>order=1,2</code>. Noting that <code>order=1</code> is equivalent to the usual TSV and L₂ regularization from RML imaging. For more information about the impact of the order see <a href="#VLBIImagePriors.MarkovRandomFieldGraph-Tuple{ComradeBase.AbstractGrid}"><code>MarkovRandomFieldGraph</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/markovrf/gmrf.jl#L59-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.GaussMarkovRandomField-Tuple{Number, MarkovRandomFieldGraph}" href="#VLBIImagePriors.GaussMarkovRandomField-Tuple{Number, MarkovRandomFieldGraph}"><code>VLBIImagePriors.GaussMarkovRandomField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GaussMarkovRandomField(ρ, cache::MarkovRandomFieldGraph)</code></pre><p>Constructs a unit variance Gaussian Markov random field using the precomputed Markov Random Field graph cache <code>cache</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/markovrf/gmrf.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.GaussMarkovRandomField-Tuple{Number, Tuple{Int64, Int64}}" href="#VLBIImagePriors.GaussMarkovRandomField-Tuple{Number, Tuple{Int64, Int64}}"><code>VLBIImagePriors.GaussMarkovRandomField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GaussMarkovRandomField(ρ, dims)</code></pre><p>Constructs a <code>order</code>ᵗʰ order Gaussian Markov random field with dimensions <code>size(img)</code>, correlation <code>ρ</code> and unit covariance.</p><p>The <code>order</code> parameter controls the smoothness of the field with higher orders being smoother. We recommend sticking with either <code>order=1,2</code>. Noting that <code>order=1</code> is equivalent to the usual TSV and L₂ regularization from RML imaging. For more information about the impact of the order see <a href="#VLBIImagePriors.MarkovRandomFieldGraph-Tuple{ComradeBase.AbstractGrid}"><code>MarkovRandomFieldGraph</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/markovrf/gmrf.jl#L75-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.ImageDirichlet" href="#VLBIImagePriors.ImageDirichlet"><code>VLBIImagePriors.ImageDirichlet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImageDirichlet(α::AbstractMatrix)
ImageDirichlet(α::Real, ny, nx)</code></pre><p>A Dirichlet distribution defined on a matrix. Samples from this produce matrices whose elements sum to unity. This is a useful image prior when you want to separately constrain the flux. The  α parameter defines the usual Dirichlet concentration amount.</p><p><strong>Notes</strong></p><p>Much of this code was taken from <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl</a> and it&#39;s Dirichlet distribution. However, some changes were made to make it faster. Additionally, we use define a custom <code>rrule</code> to speed up derivatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/dirichlet.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.ImageSimplex" href="#VLBIImagePriors.ImageSimplex"><code>VLBIImagePriors.ImageSimplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImageSimplex(ny,nx)</code></pre><p>This defines a transformation from ℝⁿ⁻¹ to the <code>n</code> probability simplex defined on an matrix with dimension <code>ny×nx</code>. This is a more natural transformation for rasterized images, which are most naturally represented as a matrix.</p><p><strong>Notes</strong></p><p>Much of this code was inspired by <a href="https://github.com/tpapp/TransformVariables.jl">TransformVariables</a>. However, we have specified custom <code>rrules</code> using Enzyme as a backend. This allowed the simplex transform to be used with Zygote and we achieved an order of magnitude speedup when computing the pullback of the simplex transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/imagesimplex.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.ImageSphericalUniform" href="#VLBIImagePriors.ImageSphericalUniform"><code>VLBIImagePriors.ImageSphericalUniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImageSphericalUniform(nx, ny)</code></pre><p>Construct a distribution where each image pixel is a 3-sphere uniform variable. This is useful for polarization where the stokes parameters are parameterized on the 3-sphere.</p><p>Currently we use a struct of vectors memory layout. That is the image is described by three matrices <code>(X,Y,Z)</code> grouped together as a tuple, where each matrix is one direction on the sphere, and we require <code>norm((X,Y,Z)) == 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/uniform.jl#L53-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.ImageUniform" href="#VLBIImagePriors.ImageUniform"><code>VLBIImagePriors.ImageUniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImageUniform(a::Real, b::Real, nx, ny)</code></pre><p>A uniform distribution in image pixels where <code>a/b</code> are the lower/upper bound for the interval. This then concatenates ny×nx uniform distributions together.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/uniform.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.MarkovRandomField" href="#VLBIImagePriors.MarkovRandomField"><code>VLBIImagePriors.MarkovRandomField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type MarkovRandomField &lt;: Distributions.Distribution{Distributions.Matrixvariate, Distributions.Continuous}</code></pre><p>An abstract type for a <code>MarkovRandomField</code>. We assume that the distribution is of the form</p><pre><code class="nohighlight hljs">p(x | ρ) = N(detQ(ρ)) f(xᵀQ(ρ)x),</code></pre><p>where <code>f</code> is a function and <code>N</code> is the normalization of the distribution, and ρ is the correlation parameter.</p><p>To implement the informal interface e.g., <code>MyRF &lt;: MarkovRandomField</code>, the user must implement</p><ul><li><code>lognorm(d::MyRF)</code>: Which computes the log of the normalization constant <code>N</code></li><li><code>unnormed_logpdf(d::MyRF, x::AbstractMatrix)</code>: Which computes f(xᵀQx)</li><li><code>Distributions._rand!(rng::AbstractRNG, d::MyRF, x::AbstractMatrix)</code>: To enable sampling  from the prior</li></ul><p>Additionally, there are a number of auto-generated function that can be overwritten:</p><ul><li><code>graph(d::MyRF)</code>: Which returns the graph structure of the Markov Random Field.  The default returns the property <code>d.graph</code>.</li><li><code>corrparam(d::MyRF)</code>: Which returns the correlation parameter ρ of the Markov Random Field.  The default returns the property <code>d.ρ</code>.</li><li><code>Base.size(d::MyRF)</code>: Which returns the size of the distribution. This defaults to the  size of the graph cache.</li><li><code>scalematrix(d::MyRF)</code>: Which computes the scale matrix <code>Q</code>, of the random field. The  default is to forward to the <code>scalematrix(graph(d), corrparm(d))</code>.</li><li><code>(c::ConditionalMarkov{&lt;:MyRF})(ρ)</code>: To map from a correlation to the distribution</li><li><code>HypercubeTransform.asflat(d::MyRF)</code>: To map from parameter space to a flattened version.  The default is <code>TransformVariables.as(Matrix, size(d)...)</code></li><li><code>Distributions.insupport(d::MyRF, x::AbstractMatrix)</code> which checks if <code>x</code> is in the  support of <code>d</code>. The default is to always return true.</li><li><code>LinearAlgebra.logdet(d::MyRF)</code> which computes the log determinant of <code>Q</code>. This defaults to  <code>logdet(graph(d), corrparam(d))</code>.</li></ul><p>Finally additional optional methods are:</p><ul><li><code>Distributions.mean(d::MyRF)</code>: Which computes the mean of the process</li><li><code>Distributions.cov(d::MyRF)</code>: Which computes the covariance matrix of the process.</li><li><code>Distributions.invcov(d::MyRF)</code>: Computes the precision matrix of the random field</li></ul><p>For an example implementation see e.g., <a href="@ref">GaussMarkovRandomField</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/markovrf/markovrf.jl#L7-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.MarkovRandomFieldGraph-Tuple{ComradeBase.AbstractGrid}" href="#VLBIImagePriors.MarkovRandomFieldGraph-Tuple{ComradeBase.AbstractGrid}"><code>VLBIImagePriors.MarkovRandomFieldGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MarkovRandomFieldGraph(grid::AbstractGrid; order=1)
MarkovRandomFieldGraph(img::AbstractMatrix; order=1)</code></pre><p>Create a <code>order</code> Markov random field using the <code>grid</code> or <code>image</code> as its dimension.</p><p>The <code>order</code> keyword argument specifies the order of the Markov random process and is generally given by the precision matrix</p><pre><code class="nohighlight hljs">Qₙ = τ(κI + G)ⁿ</code></pre><p>where <code>n = order</code>, I is the identity matrix, G is specified by the first order stencil</p><pre><code class="nohighlight hljs">.  -1  .
-1  4  -1
.   4  .</code></pre><p>κ is the Markov process hyper-parameters. For <code>n=1</code> κ is related to the correlation length ρ of the random field by</p><pre><code class="nohighlight hljs">ρ = 1/κ</code></pre><p>while for <code>n&gt;1</code> it is given by</p><pre><code class="nohighlight hljs">ρ = √(8(n-1))/κ</code></pre><p>Note that κ isn&#39;t set in the <code>MarkovRandomFieldGraph</code>, but rather once the noise process is set, i.e. one of the subtypes of <a href="#VLBIImagePriors.MarkovRandomField"><code>MarkovRandomField</code></a>.</p><p>Finally τ is chosen so that the marginal variance of the random field is unity. For <code>n=1</code></p><pre><code class="nohighlight hljs">τ = 1</code></pre><p>for <code>n=2</code></p><pre><code class="nohighlight hljs">τ = 4πκ²</code></pre><p>and for <code>n&gt;2</code> we have</p><pre><code class="nohighlight hljs">τ = (N+1)4π κ²⁽ⁿ⁺¹⁾</code></pre><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = MarkovRandomFieldGraph(imagepixels(10.0, 10.0, 64, 64))
julia&gt; ρ = 10 # correlation length
julia&gt; d = GaussMarkovRandomField(ρ, m) # build the Gaussian Markov random field</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/markovrf/cache.jl#L84-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.NamedDist-Union{Tuple{NamedTuple{N}}, Tuple{N}} where N" href="#VLBIImagePriors.NamedDist-Union{Tuple{NamedTuple{N}}, Tuple{N}} where N"><code>VLBIImagePriors.NamedDist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NamedDist(d::NamedTuple{N})
NamedDist(;dists...)</code></pre><p>A Distribution with names <code>N</code>. This is useful to construct a set of random variables with a set of names attached to them.</p><pre><code class="language-julia-repl hljs">julia&gt; d = NamedDist((a=Normal(), b = Uniform(), c = MvNormal(randn(2), rand(2))))
julia&gt; x = rand(d)
(a = 0.13789342, b = 0.2347895, c = [2.023984392, -3.09023840923])
julia&gt; logpdf(d, x)</code></pre><p>Note that NamedDist values passed to NamedDist can also be abstract collections of distributions as well</p><pre><code class="language-julia-repl hljs">julia&gt; d = NamedDist(a = Normal(),
                     b = MvNormal(ones(2)),
                     c = (Uniform(), InverseGamma())
                     d = (a = Normal(), Beta)
                    )</code></pre><p>How this is done internally is considered an implementation detail and is not part of the public interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/namedist.jl#L45-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.SphericalUnitVector" href="#VLBIImagePriors.SphericalUnitVector"><code>VLBIImagePriors.SphericalUnitVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SphericalUnitVector{N}()</code></pre><p>A transformation from a set of <code>N+1</code> vectors to the <code>N</code> sphere. The set of <code>N+1</code> vectors are inherently assumed to be <code>N+1</code> a distributed according to a unit multivariate Normal distribution.</p><p><strong>Notes</strong></p><p>For more information about this transformation see the Stan <a href="https://mc-stan.org/docs/reference-manual/unit-vector.html">manual</a>. In the future this may be depricated when <a href="https://github.com/tpapp/TransformVariables.jl/pull/67"></a> is merged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/angular_transforms.jl#L64-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.TDistMarkovRandomField" href="#VLBIImagePriors.TDistMarkovRandomField"><code>VLBIImagePriors.TDistMarkovRandomField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TDistMarkovRandomField{T&lt;:Number, C} &lt;: VLBIImagePriors.MarkovRandomField</code></pre><p>A image prior based off of the first-order Multivariate T distribution Markov random field.</p><p><strong>Fields</strong></p><ul><li><code>ρ</code>: The correlation length of the random field.</li></ul><ul><li><code>ν</code>: The student T &quot;degrees of freedom parameter which ≥ 1 for a proper prior</li></ul><ul><li><code>graph</code>: The Markov Random Field graph cache used to define the specific Markov random field class used.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; ρ, ν = 16.0, 1.0
julia&gt; d = TDistMarkovRandomField(ρ, ν, (32, 32))
julia&gt; cache = MarkovRandomFieldGraph(Float64, (32, 32)) # now instead construct the cache
julia&gt; d2 = TDistMarkovRandomField(ρ, ν, cache)
julia&gt; invcov(d) ≈ invcov(d2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/markovrf/studentTrf.jl#L7-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.TDistMarkovRandomField-Tuple{Number, Number, AbstractMatrix}" href="#VLBIImagePriors.TDistMarkovRandomField-Tuple{Number, Number, AbstractMatrix}"><code>VLBIImagePriors.TDistMarkovRandomField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TDistMarkovRandomField(ρ, ν, img::AbstractArray; order=1)</code></pre><p>Constructs a first order TDist Markov random field with zero median dimensions <code>size(img)</code>, correlation <code>ρ</code> and degrees of freedom ν.</p><p>Note <code>ν ≥ 1</code> to be a well-defined probability distribution.</p><p>The <code>order</code> parameter controls the smoothness of the field with higher orders being smoother. We recommend sticking with either <code>order=1,2</code>. For more information about the impact of the order see <a href="#VLBIImagePriors.MarkovRandomFieldGraph-Tuple{ComradeBase.AbstractGrid}"><code>MarkovRandomFieldGraph</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/markovrf/studentTrf.jl#L72-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.TDistMarkovRandomField-Tuple{Number, Number, MarkovRandomFieldGraph}" href="#VLBIImagePriors.TDistMarkovRandomField-Tuple{Number, Number, MarkovRandomFieldGraph}"><code>VLBIImagePriors.TDistMarkovRandomField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TDistMarkovRandomField(ρ, ν, cache::MarkovRandomFieldGraph)</code></pre><p>Constructs a first order TDist Markov random field with zero mean ,correlation <code>ρ</code>, degrees of freedom <code>ν</code>, and the precomputed MarkovRandomFieldGraph <code>cache</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/markovrf/studentTrf.jl#L91-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.TDistMarkovRandomField-Tuple{Number, Number, Tuple{Int64, Int64}}" href="#VLBIImagePriors.TDistMarkovRandomField-Tuple{Number, Number, Tuple{Int64, Int64}}"><code>VLBIImagePriors.TDistMarkovRandomField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TDistMarkovRandomField(ρ, ν, dims)</code></pre><p>Constructs a first order TDist Markov random field with zero mean ,correlation <code>ρ</code>, degrees of freedom <code>ν</code>, with dimension <code>dims</code>.</p><p>The <code>order</code> parameter controls the smoothness of the field with higher orders being smoother. We recommend sticking with either <code>order=1,2</code>. For more information about the impact of the order see <a href="#VLBIImagePriors.MarkovRandomFieldGraph-Tuple{ComradeBase.AbstractGrid}"><code>MarkovRandomFieldGraph</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/markovrf/studentTrf.jl#L105-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.TMRF" href="#VLBIImagePriors.TMRF"><code>VLBIImagePriors.TMRF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Alias for `TDistMarkovRandomField`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/markovrf/studentTrf.jl#L50-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.WrappedUniform" href="#VLBIImagePriors.WrappedUniform"><code>VLBIImagePriors.WrappedUniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WrappedUniform(period)</code></pre><p>Constructs a potentially multivariate uniform distribution that is wrapped a given <code>period</code>. That is</p><pre><code class="language-julia hljs">d = WrappedUniform(period)
logpdf(d, x) ≈ logpdf(d, x+period)</code></pre><p>for any <code>x</code>.</p><p>If <code>period</code> is a vector this creates a multivariate independent wrapped uniform distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/angular_dists.jl#L110-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.alr!-Tuple{Any, Any}" href="#VLBIImagePriors.alr!-Tuple{Any, Any}"><code>VLBIImagePriors.alr!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alr!(x, y)</code></pre><p>Compute the inverse alr transform. That is <code>x</code> lives in ℜⁿ and <code>y</code>, lives in Δⁿ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/logratio_transform.jl#L211-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.alrinv!-Tuple{Any, Any}" href="#VLBIImagePriors.alrinv!-Tuple{Any, Any}"><code>VLBIImagePriors.alrinv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alrinv!(x, y)</code></pre><p>Computes the additive logit transform inplace. This converts from ℜⁿ → Δⁿ where Δⁿ is the n-simplex</p><p><strong>Notes</strong></p><p>This function is mainly to transform the GaussMarkovRandomField to live on the simplex. In order to preserve the nice properties of the GRMF namely the log det we only use <code>y[begin:end-1]</code> elements and the last one is not included in the transform. This shouldn&#39;t be a problem since the additional parameter is just a dummy in that case and the Gaussian prior should ensure it is easy to sample from.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/logratio_transform.jl#L143-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.clr!-Tuple{Any, Any}" href="#VLBIImagePriors.clr!-Tuple{Any, Any}"><code>VLBIImagePriors.clr!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clr!(x, y)</code></pre><p>Compute the inverse alr transform. That is <code>x</code> lives in ℜⁿ and <code>y</code>, lives in Δⁿ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/logratio_transform.jl#L199-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.clrinv!-Tuple{Any, Any}" href="#VLBIImagePriors.clrinv!-Tuple{Any, Any}"><code>VLBIImagePriors.clrinv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clrinv!(x, y)</code></pre><p>Computes the additive logit transform inplace. This converts from ℜⁿ → Δⁿ where Δⁿ is the n-simplex</p><p><strong>Notes</strong></p><p>This function is mainly to transform the GaussMarkovRandomField to live on the simplex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/logratio_transform.jl#L126-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.corrparam-Tuple{VLBIImagePriors.MarkovRandomField}" href="#VLBIImagePriors.corrparam-Tuple{VLBIImagePriors.MarkovRandomField}"><code>VLBIImagePriors.corrparam</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">corrparam(m::MarkovRandomField)</code></pre><p>Returns the correlation parameter of the Markov Random field <code>m</code>. For details about the correlation parmeter see <a href="#VLBIImagePriors.MarkovRandomFieldGraph-Tuple{ComradeBase.AbstractGrid}"><code>MarkovRandomFieldGraph</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/markovrf/markovrf.jl#L67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.graph-Tuple{VLBIImagePriors.MarkovRandomField}" href="#VLBIImagePriors.graph-Tuple{VLBIImagePriors.MarkovRandomField}"><code>VLBIImagePriors.graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">graph(m::MarkovRandomField)</code></pre><p>Returns the graph or graph cache of the Markov Random field <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/markovrf/markovrf.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.matern-Tuple{Type{&lt;:Number}, Tuple{Int64, Int64}}" href="#VLBIImagePriors.matern-Tuple{Type{&lt;:Number}, Tuple{Int64, Int64}}"><code>VLBIImagePriors.matern</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matern([T=Float64], dims::Dims{2})
matern([T=Float64], dims::Int...)</code></pre><p>Creates an approximate Matern Gaussian process that approximates the Matern process on a regular grid which cyclic boundary conditions. This function returns a tuple of two objects</p><ul><li>A functor <code>f</code> of type <code>StationaryMatern</code> that iid-Normal noise to a draw from the Matern process. The functor call arguments are <code>f(s, ρ, ν)</code> where <code>s</code> is the random white Gaussian noise with dimension <code>dims</code>, <code>ρ</code> is the correlation length, and <code>ν</code> is Matern smoothness parameter</li><li>The a set of <code>prod(dims)</code> standard Normal distributions that can serve as the noise generator for the process.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transform, dstd = matern((32, 32))
julia&gt; draw_matern = transform(rand(dstd), 10.0, 2.0)
julia&gt; ones(32, 32) .+ 5.* draw_matern # change the mean and variance of the field</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/matern.jl#L48-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.matern-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#VLBIImagePriors.matern-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>VLBIImagePriors.matern</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matern(img::AbstractMatrix)</code></pre><p>Creates an approximate Matern Gaussian process with dimension <code>size(img)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/matern.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.scalematrix-Tuple{VLBIImagePriors.MarkovRandomField}" href="#VLBIImagePriors.scalematrix-Tuple{VLBIImagePriors.MarkovRandomField}"><code>VLBIImagePriors.scalematrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scalematrix(m::MarkovRandomField)</code></pre><p>Return the scale matrix for the <code>Markov Random field</code>. For a Gaussian Markov random field this corresponds to the precision matrix of the Gaussian field.</p><p>For other random processes this is the <code>metric</code> of the inner product, i.e. <code>Q</code> in</p><pre><code class="nohighlight hljs">xᵀQx</code></pre><p>which is the distance from the origin to <code>x</code> using the metric <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/markovrf/markovrf.jl#L80-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.to_real-Tuple{VLBIImagePriors.LogRatioTransform, Any}" href="#VLBIImagePriors.to_real-Tuple{VLBIImagePriors.LogRatioTransform, Any}"><code>VLBIImagePriors.to_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_real(t::LogRatioTransform, y)</code></pre><p>Transform the value <code>u</code> that lives on the simplex to a value in the real vector space. See <code>subtypes(LogRatioTransform)</code> for a list of possible transformations.</p><p>The inverse of this transform is given by <a href="#VLBIImagePriors.to_simplex-Tuple{VLBIImagePriors.LogRatioTransform, Any}"><code>to_simplex(t, x)</code></a>.</p><p><strong>Example</strong></p><p>```julia julia&gt; y = randn(100) julia&gt; y .= y./sum(y) julia&gt; to<em>real(CenteredLR(), y) julia&gt; to</em>real(AdditiveLR(), y)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/logratio_transform.jl#L93-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.to_simplex!-Tuple{AdditiveLR, Any, Any}" href="#VLBIImagePriors.to_simplex!-Tuple{AdditiveLR, Any, Any}"><code>VLBIImagePriors.to_simplex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_simplex!(t::LogRatioTransform, y, x)</code></pre><p>Transform the vector <code>x</code> assumed to be a real valued array to the simplex using the log-ratio transform <code>t</code> and stores the value in <code>y</code>.</p><p>The inverse of this transform is given by <a href="@ref"><code>to_real!(t, x, y)</code></a> where <code>y</code> is a vector that sums to unity, i.e. it lives on the simplex.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; x = randn(100)
julia&gt; to_simplex(CenteredLR(), x)
julia&gt; to_simplex(AdditiveLR(), x)

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/logratio_transform.jl#L65-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBIImagePriors.to_simplex-Tuple{VLBIImagePriors.LogRatioTransform, Any}" href="#VLBIImagePriors.to_simplex-Tuple{VLBIImagePriors.LogRatioTransform, Any}"><code>VLBIImagePriors.to_simplex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_simplex(t::LogRatioTransform, x)</code></pre><p>Transform the vector <code>x</code> assumed to be a real valued array to the simplex using the log-ratio transform <code>t</code>. See <code>subtypes(LogRatioTransform)</code> for a list of possible transformations.</p><p>The inverse of this transform is given by <a href="#VLBIImagePriors.to_real-Tuple{VLBIImagePriors.LogRatioTransform, Any}"><code>to_real(t, y)</code></a> where <code>y</code> is a vector that sums to unity, i.e. it lives on the simplex.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; x = randn(100)
julia&gt; to_simplex(CenteredLR(), x)
julia&gt; to_simplex(AdditiveLR(), x)

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VLBIImagePriors.jl/blob/44a13404e135d6eca35a8e1b3a93761f982ccf77/src/logratio_transform.jl#L40-L58">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 23 January 2024 20:23">Tuesday 23 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
